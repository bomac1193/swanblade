/**
 * Export Formats - Game Engine Integration
 *
 * Export stem bundles to Unity, Unreal, Wwise, and FMOD formats
 */

import type { StemBundle, BundleManifest } from "./stemGenerator";
import type { GameState } from "./gameStateEngine";

// ==================== Unity Export ====================

export interface UnityAudioMetadata {
  name: string;
  gameState: string;
  bpm: number;
  key: string;
  duration: number;
  stems: Array<{
    name: string;
    role: string;
    audioClipName: string;
  }>;
  provenance: {
    generator: string;
    timestamp: string;
    identityId?: string;
  };
}

/**
 * Generate Unity ScriptableObject C# code
 */
export function generateUnityScriptableObject(bundle: StemBundle): string {
  const className = `${toPascalCase(bundle.gameState)}AudioBundle`;

  return `using UnityEngine;

/// <summary>
/// Auto-generated audio bundle for ${bundle.gameState} game state
/// Generated by Swanblade on ${bundle.createdAt}
/// </summary>
[CreateAssetMenu(fileName = "${bundle.name}", menuName = "Swanblade/Audio Bundle")]
public class ${className} : ScriptableObject
{
    [Header("Bundle Info")]
    public string bundleId = "${bundle.id}";
    public string gameState = "${bundle.gameState}";
    public float bpm = ${bundle.manifest.bpm}f;
    public string musicalKey = "${bundle.manifest.key}";
    public float duration = ${bundle.manifest.duration}f;

    [Header("Stems")]
${bundle.stems
  .map(
    (stem) => `    public AudioClip ${stem.stemType}Stem;`
  )
  .join("\n")}

    [Header("Provenance")]
    public string provenanceTimestamp = "${bundle.manifest.provenance.timestamp}";
${bundle.manifest.provenance.identityId ? `    public string identityId = "${bundle.manifest.provenance.identityId}";` : ""}
${bundle.stems
  .filter((s) => s.provenanceCid)
  .map(
    (stem) => `    public string ${stem.stemType}ProvenanceCid = "${stem.provenanceCid}";`
  )
  .join("\n")}

    /// <summary>
    /// Get all stems as an array for mixing
    /// </summary>
    public AudioClip[] GetAllStems()
    {
        return new AudioClip[] { ${bundle.stems.map((s) => `${s.stemType}Stem`).join(", ")} };
    }

    /// <summary>
    /// Get stems by role (foundation, accent, atmosphere, transition)
    /// </summary>
    public AudioClip[] GetStemsByRole(string role)
    {
        switch (role.ToLower())
        {
${generateUnityRoleSwitchCases(bundle)}
            default:
                return new AudioClip[0];
        }
    }
}
`;
}

function generateUnityRoleSwitchCases(bundle: StemBundle): string {
  const roleGroups: Record<string, string[]> = {};

  for (const stem of bundle.stems) {
    const role = bundle.manifest.stems.find((s) => s.type === stem.stemType)?.role || "accent";
    if (!roleGroups[role]) roleGroups[role] = [];
    roleGroups[role].push(`${stem.stemType}Stem`);
  }

  return Object.entries(roleGroups)
    .map(
      ([role, stems]) =>
        `            case "${role}":\n                return new AudioClip[] { ${stems.join(", ")} };`
    )
    .join("\n");
}

// ==================== Unreal Export ====================

/**
 * Generate Unreal DataAsset C++ header
 */
export function generateUnrealDataAsset(bundle: StemBundle): string {
  const className = `U${toPascalCase(bundle.gameState)}AudioBundle`;

  return `// Auto-generated audio bundle for ${bundle.gameState} game state
// Generated by Swanblade on ${bundle.createdAt}

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "${toPascalCase(bundle.gameState)}AudioBundle.generated.h"

UCLASS(BlueprintType)
class YOURGAME_API ${className} : public UDataAsset
{
    GENERATED_BODY()

public:
    // Bundle Info
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Bundle Info")
    FString BundleId = TEXT("${bundle.id}");

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Bundle Info")
    FString GameState = TEXT("${bundle.gameState}");

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Bundle Info")
    float BPM = ${bundle.manifest.bpm}f;

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Bundle Info")
    FString MusicalKey = TEXT("${bundle.manifest.key}");

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Bundle Info")
    float Duration = ${bundle.manifest.duration}f;

    // Stems
${bundle.stems
  .map(
    (stem) =>
      `    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Stems")
    USoundWave* ${toPascalCase(stem.stemType)}Stem;`
  )
  .join("\n\n")}

    // Provenance
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Provenance")
    FString ProvenanceTimestamp = TEXT("${bundle.manifest.provenance.timestamp}");

${
  bundle.manifest.provenance.identityId
    ? `    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Provenance")
    FString IdentityId = TEXT("${bundle.manifest.provenance.identityId}");`
    : ""
}

    // Get all stems
    UFUNCTION(BlueprintCallable, Category = "Audio")
    TArray<USoundWave*> GetAllStems() const
    {
        return { ${bundle.stems.map((s) => `${toPascalCase(s.stemType)}Stem`).join(", ")} };
    }
};
`;
}

// ==================== Wwise Export ====================

/**
 * Generate Wwise WAAPI metadata XML
 */
export function generateWwiseMetadata(bundle: StemBundle): string {
  return `<?xml version="1.0" encoding="utf-8"?>
<!--
  Swanblade Audio Bundle Metadata for Wwise
  Bundle: ${bundle.name}
  Game State: ${bundle.gameState}
  Generated: ${bundle.createdAt}
-->
<WwiseDocument Version="1.0">
  <AudioBundle>
    <Id>${bundle.id}</Id>
    <Name>${bundle.name}</Name>
    <GameState>${bundle.gameState}</GameState>
    <BPM>${bundle.manifest.bpm}</BPM>
    <Key>${bundle.manifest.key}</Key>
    <Duration>${bundle.manifest.duration}</Duration>

    <Stems>
${bundle.stems
  .map(
    (stem) => `      <Stem>
        <Type>${stem.stemType}</Type>
        <Role>${bundle.manifest.stems.find((s) => s.type === stem.stemType)?.role || "accent"}</Role>
        <Filename>${stem.stemType}.wav</Filename>
        ${stem.provenanceCid ? `<ProvenanceCid>${stem.provenanceCid}</ProvenanceCid>` : ""}
      </Stem>`
  )
  .join("\n")}
    </Stems>

    <Provenance>
      <Generator>Swanblade</Generator>
      <Timestamp>${bundle.manifest.provenance.timestamp}</Timestamp>
      ${bundle.manifest.provenance.identityId ? `<IdentityId>${bundle.manifest.provenance.identityId}</IdentityId>` : ""}
    </Provenance>

    <SuggestedMapping>
      <Switch_Group Name="GameState">
        <Switch Name="${bundle.gameState}" />
      </Switch_Group>
      <Music_Segment Name="${bundle.name}_Segment">
        <Tempo>${bundle.manifest.bpm}</Tempo>
${bundle.stems.map((stem) => `        <Track Name="${stem.stemType}" File="${stem.stemType}.wav" />`).join("\n")}
      </Music_Segment>
    </SuggestedMapping>
  </AudioBundle>
</WwiseDocument>
`;
}

// ==================== FMOD Export ====================

/**
 * Generate FMOD Studio metadata XML
 */
export function generateFMODMetadata(bundle: StemBundle): string {
  return `<?xml version="1.0" encoding="utf-8"?>
<!--
  Swanblade Audio Bundle Metadata for FMOD Studio
  Bundle: ${bundle.name}
  Game State: ${bundle.gameState}
  Generated: ${bundle.createdAt}
-->
<FMODBundle Version="1.0">
  <Metadata>
    <BundleId>${bundle.id}</BundleId>
    <Name>${bundle.name}</Name>
    <GameState>${bundle.gameState}</GameState>
    <BPM>${bundle.manifest.bpm}</BPM>
    <Key>${bundle.manifest.key}</Key>
    <Duration>${bundle.manifest.duration}</Duration>
    <Generator>Swanblade</Generator>
    <GeneratedAt>${bundle.manifest.provenance.timestamp}</GeneratedAt>
    ${bundle.manifest.provenance.identityId ? `<IdentityId>${bundle.manifest.provenance.identityId}</IdentityId>` : ""}
  </Metadata>

  <Tracks>
${bundle.stems
  .map(
    (stem) => `    <Track>
      <Name>${stem.stemType}</Name>
      <Role>${bundle.manifest.stems.find((s) => s.type === stem.stemType)?.role || "accent"}</Role>
      <AudioFile>${stem.stemType}.wav</AudioFile>
      ${stem.provenanceCid ? `<ProvenanceCid>${stem.provenanceCid}</ProvenanceCid>` : ""}
    </Track>`
  )
  .join("\n")}
  </Tracks>

  <SuggestedSetup>
    <Event Name="Music/${bundle.gameState}">
      <Parameter Name="Intensity" Type="Continuous" Min="0" Max="1" />
${bundle.stems
  .map(
    (stem) =>
      `      <Instrument Name="${stem.stemType}" File="${stem.stemType}.wav" />`
  )
  .join("\n")}
    </Event>
  </SuggestedSetup>

  <Provenance>
${bundle.stems
  .filter((s) => s.provenanceCid)
  .map(
    (stem) =>
      `    <Stem Type="${stem.stemType}" Cid="${stem.provenanceCid}" />`
  )
  .join("\n")}
  </Provenance>
</FMODBundle>
`;
}

// ==================== JSON Manifest ====================

/**
 * Generate universal JSON manifest
 */
export function generateJSONManifest(bundle: StemBundle): string {
  return JSON.stringify(
    {
      version: "1.0",
      generator: "swanblade",
      bundle: {
        id: bundle.id,
        name: bundle.name,
        gameState: bundle.gameState,
        paletteId: bundle.paletteId,
        createdAt: bundle.createdAt,
      },
      audio: {
        bpm: bundle.manifest.bpm,
        key: bundle.manifest.key,
        duration: bundle.manifest.duration,
      },
      stems: bundle.stems.map((stem) => ({
        type: stem.stemType,
        filename: `${stem.stemType}.wav`,
        role: bundle.manifest.stems.find((s) => s.type === stem.stemType)?.role,
        duration: stem.duration,
        metadata: stem.metadata,
        provenanceCid: stem.provenanceCid,
      })),
      provenance: bundle.manifest.provenance,
    },
    null,
    2
  );
}

// ==================== ZIP Bundle Creator ====================

export interface ExportBundle {
  manifest: string;
  unity?: string;
  unreal?: string;
  wwise?: string;
  fmod?: string;
  license: string;
}

/**
 * Generate all export files for a bundle
 */
export function generateAllExports(bundle: StemBundle): ExportBundle {
  return {
    manifest: generateJSONManifest(bundle),
    unity: generateUnityScriptableObject(bundle),
    unreal: generateUnrealDataAsset(bundle),
    wwise: generateWwiseMetadata(bundle),
    fmod: generateFMODMetadata(bundle),
    license: generateLicenseFile(bundle),
  };
}

/**
 * Generate license file with provenance info
 */
function generateLicenseFile(bundle: StemBundle): string {
  const hasProvenance = bundle.stems.some((s) => s.provenanceCid);

  return `SWANBLADE AUDIO BUNDLE LICENSE
==============================

Bundle: ${bundle.name}
ID: ${bundle.id}
Generated: ${bundle.createdAt}

PROVENANCE INFORMATION
----------------------
${
  hasProvenance
    ? `This audio bundle has verifiable provenance through the ∞8 protocol.
All stems can be traced to their origin and verified on-chain.

Identity: ${bundle.manifest.provenance.identityId || "Not specified"}
Generator: Swanblade

Stem Provenance CIDs:
${bundle.stems
  .filter((s) => s.provenanceCid)
  .map((s) => `- ${s.stemType}: ${s.provenanceCid}`)
  .join("\n")}

Verify at: https://verify.o8.audio/{CID}`
    : `This audio bundle does not have on-chain provenance.
Consider stamping with ∞8 protocol for full attribution tracking.`
}

USAGE RIGHTS
------------
This audio was generated using AI models through Swanblade.
Usage rights depend on your subscription tier and the underlying model providers.

For commercial use, ensure you have appropriate licensing from:
- Swanblade (generation platform)
- Underlying model provider (Replicate, fal.ai, etc.)

ATTRIBUTION
-----------
Generated by Swanblade
https://swanblade.io

For provenance verification: https://o8.audio
`;
}

// ==================== Helpers ====================

function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]+/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join("");
}
