/**
 * Unreal Export - Full Package Generation
 *
 * Generates complete Unreal Engine-ready packages including:
 * - Audio files organized by type
 * - C++ AudioManager class
 * - DataAsset definitions
 * - Blueprint-callable functions
 * - RTPC parameters for adaptive audio
 */

import type { StemBundle } from "../stemGenerator";
import type { GameState } from "../gameStateEngine";

// ==================== Unreal Package Types ====================

export interface UnrealPackage {
  manifest: UnrealManifest;
  audioManagerHeader: string;
  audioManagerCpp: string;
  dataAssets: Map<string, string>;
  blueprintLibrary: string;
  gameplayTags: string;
  readme: string;
}

export interface UnrealManifest {
  name: string;
  version: string;
  unrealVersion: string;
  generator: string;
  generatedAt: string;
  bundles: UnrealBundleInfo[];
}

export interface UnrealBundleInfo {
  id: string;
  name: string;
  gameState: GameState;
  stemCount: number;
  bpm: number;
  duration: number;
}

// ==================== AudioManager Header ====================

/**
 * Generate Unreal AudioManager header file
 */
export function generateUnrealAudioManagerHeader(
  bundles: StemBundle[],
  projectName: string = "SwanbladeAudio"
): string {
  const stateEnumValues = [...new Set(bundles.map((b) => `E${toPascalCase(b.gameState)}`))];

  return `// ${projectName} Audio Manager
// Auto-generated by Swanblade
// DO NOT EDIT - Regenerate from Swanblade if changes are needed

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Components/AudioComponent.h"
#include "Sound/SoundWave.h"
#include "Sound/SoundCue.h"
#include "SwanbladeAudioManager.generated.h"

/**
 * Game audio states matching Swanblade game states
 */
UENUM(BlueprintType)
enum class ESwanbladeAudioState : uint8
{
${stateEnumValues.map((s) => `    ${s} UMETA(DisplayName = "${s.slice(1)}")`).join(",\n")}
};

/**
 * Stem types for individual track control
 */
UENUM(BlueprintType)
enum class ESwanbladeStemType : uint8
{
    Drums,
    Bass,
    Melody,
    Harmony,
    Atmosphere,
    FX,
    Vocals
};

/**
 * Delegate for state change notifications
 */
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnAudioStateChanged, ESwanbladeAudioState, OldState, ESwanbladeAudioState, NewState);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBeatHit, int32, BeatNumber);

/**
 * Swanblade Audio Manager - Controls game state-driven audio playback
 */
UCLASS(BlueprintType, Blueprintable)
class ${projectName.toUpperCase()}_API ASwanbladeAudioManager : public AActor
{
    GENERATED_BODY()

public:
    ASwanbladeAudioManager();

    // Singleton access
    UFUNCTION(BlueprintCallable, Category = "Swanblade|Audio")
    static ASwanbladeAudioManager* GetInstance();

protected:
    virtual void BeginPlay() override;
    virtual void Tick(float DeltaTime) override;

public:
    // ==================== State Management ====================

    /**
     * Transition to a new audio state with crossfade
     */
    UFUNCTION(BlueprintCallable, Category = "Swanblade|Audio")
    void SetAudioState(ESwanbladeAudioState NewState);

    /**
     * Get current audio state
     */
    UFUNCTION(BlueprintPure, Category = "Swanblade|Audio")
    ESwanbladeAudioState GetCurrentState() const { return CurrentState; }

    /**
     * Get current BPM
     */
    UFUNCTION(BlueprintPure, Category = "Swanblade|Audio")
    float GetCurrentBPM() const;

    // ==================== Stem Control ====================

    /**
     * Set volume for a specific stem type (0-1)
     */
    UFUNCTION(BlueprintCallable, Category = "Swanblade|Audio|Stems")
    void SetStemVolume(ESwanbladeStemType StemType, float Volume);

    /**
     * Get current volume for a stem type
     */
    UFUNCTION(BlueprintPure, Category = "Swanblade|Audio|Stems")
    float GetStemVolume(ESwanbladeStemType StemType) const;

    /**
     * Mute a specific stem
     */
    UFUNCTION(BlueprintCallable, Category = "Swanblade|Audio|Stems")
    void MuteStem(ESwanbladeStemType StemType);

    /**
     * Unmute a specific stem
     */
    UFUNCTION(BlueprintCallable, Category = "Swanblade|Audio|Stems")
    void UnmuteStem(ESwanbladeStemType StemType);

    // ==================== RTPC Integration ====================

    /**
     * Map a gameplay parameter to stem volume
     * Example: Health -> Drums volume
     */
    UFUNCTION(BlueprintCallable, Category = "Swanblade|Audio|RTPC")
    void MapParameterToStem(FName ParameterName, ESwanbladeStemType StemType, float MinValue = 0.f, float MaxValue = 1.f);

    /**
     * Update a mapped parameter value
     */
    UFUNCTION(BlueprintCallable, Category = "Swanblade|Audio|RTPC")
    void SetParameterValue(FName ParameterName, float Value);

    // ==================== Events ====================

    /**
     * Called when audio state changes
     */
    UPROPERTY(BlueprintAssignable, Category = "Swanblade|Audio|Events")
    FOnAudioStateChanged OnAudioStateChanged;

    /**
     * Called on each beat (synced to BPM)
     */
    UPROPERTY(BlueprintAssignable, Category = "Swanblade|Audio|Events")
    FOnBeatHit OnBeatHit;

protected:
    // ==================== Configuration ====================

    UPROPERTY(EditDefaultsOnly, Category = "Configuration")
    float CrossfadeDuration = 1.5f;

    UPROPERTY(EditDefaultsOnly, Category = "Configuration")
    float StemFadeSpeed = 0.5f;

    // ==================== Audio Bundles ====================

${bundles.map((b) => `    UPROPERTY(EditDefaultsOnly, Category = "Audio Bundles")
    class U${toPascalCase(b.gameState)}AudioBundle* ${b.gameState}Bundle;`).join("\n\n")}

private:
    // Current state
    UPROPERTY()
    ESwanbladeAudioState CurrentState;

    // Audio components for each stem
    UPROPERTY()
    TMap<ESwanbladeStemType, UAudioComponent*> StemComponents;

    // Target volumes for smooth transitions
    TMap<ESwanbladeStemType, float> TargetStemVolumes;

    // Cached volumes before mute
    TMap<ESwanbladeStemType, float> CachedStemVolumes;

    // Parameter mappings
    struct FParameterMapping
    {
        ESwanbladeStemType StemType;
        float MinValue;
        float MaxValue;
    };
    TMap<FName, FParameterMapping> ParameterMappings;

    // Beat tracking
    float BeatAccumulator = 0.f;
    int32 CurrentBeat = 0;

    // Singleton instance
    static ASwanbladeAudioManager* Instance;

    // Helper functions
    void InitializeStemComponents();
    void CrossfadeToState(ESwanbladeAudioState NewState);
    class USwanbladeAudioBundleBase* GetBundleForState(ESwanbladeAudioState State);
    void UpdateBeatTracking(float DeltaTime);
};
`;
}

// ==================== AudioManager CPP ====================

/**
 * Generate Unreal AudioManager implementation file
 */
export function generateUnrealAudioManagerCpp(
  bundles: StemBundle[],
  projectName: string = "SwanbladeAudio"
): string {
  return `// ${projectName} Audio Manager Implementation
// Auto-generated by Swanblade

#include "SwanbladeAudioManager.h"
#include "Kismet/GameplayStatics.h"
#include "Components/AudioComponent.h"

ASwanbladeAudioManager* ASwanbladeAudioManager::Instance = nullptr;

ASwanbladeAudioManager::ASwanbladeAudioManager()
{
    PrimaryActorTick.bCanEverTick = true;
    CurrentState = ESwanbladeAudioState::E${toPascalCase(bundles[0]?.gameState || "menu")};
}

ASwanbladeAudioManager* ASwanbladeAudioManager::GetInstance()
{
    return Instance;
}

void ASwanbladeAudioManager::BeginPlay()
{
    Super::BeginPlay();

    // Register singleton
    if (Instance == nullptr)
    {
        Instance = this;
    }
    else if (Instance != this)
    {
        Destroy();
        return;
    }

    InitializeStemComponents();
}

void ASwanbladeAudioManager::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);

    // Smooth volume transitions
    for (auto& Pair : StemComponents)
    {
        if (Pair.Value)
        {
            float CurrentVolume = Pair.Value->VolumeMultiplier;
            float TargetVolume = TargetStemVolumes.FindRef(Pair.Key);

            float NewVolume = FMath::FInterpTo(CurrentVolume, TargetVolume, DeltaTime, StemFadeSpeed);
            Pair.Value->SetVolumeMultiplier(NewVolume);

            // Stop playback when faded out
            if (NewVolume < 0.01f && Pair.Value->IsPlaying() && TargetVolume == 0.f)
            {
                Pair.Value->Stop();
            }
        }
    }

    // Beat tracking
    UpdateBeatTracking(DeltaTime);
}

void ASwanbladeAudioManager::InitializeStemComponents()
{
    TArray<ESwanbladeStemType> StemTypes = {
        ESwanbladeStemType::Drums,
        ESwanbladeStemType::Bass,
        ESwanbladeStemType::Melody,
        ESwanbladeStemType::Harmony,
        ESwanbladeStemType::Atmosphere,
        ESwanbladeStemType::FX,
        ESwanbladeStemType::Vocals
    };

    for (ESwanbladeStemType StemType : StemTypes)
    {
        UAudioComponent* AudioComp = NewObject<UAudioComponent>(this);
        AudioComp->RegisterComponent();
        AudioComp->AttachToComponent(GetRootComponent(), FAttachmentTransformRules::KeepRelativeTransform);
        AudioComp->bAutoDestroy = false;
        AudioComp->bAutoActivate = false;
        AudioComp->VolumeMultiplier = 0.f;

        StemComponents.Add(StemType, AudioComp);
        TargetStemVolumes.Add(StemType, 0.f);
        CachedStemVolumes.Add(StemType, 1.f);
    }
}

void ASwanbladeAudioManager::SetAudioState(ESwanbladeAudioState NewState)
{
    if (CurrentState == NewState) return;

    ESwanbladeAudioState OldState = CurrentState;
    CurrentState = NewState;

    CrossfadeToState(NewState);

    OnAudioStateChanged.Broadcast(OldState, NewState);
    UE_LOG(LogTemp, Log, TEXT("[SwanbladeAudio] State change: %d -> %d"), (int32)OldState, (int32)NewState);
}

void ASwanbladeAudioManager::CrossfadeToState(ESwanbladeAudioState NewState)
{
    // Fade out all stems
    for (auto& Pair : TargetStemVolumes)
    {
        Pair.Value = 0.f;
    }

    // Get bundle for new state
    USwanbladeAudioBundleBase* Bundle = GetBundleForState(NewState);
    if (!Bundle)
    {
        UE_LOG(LogTemp, Warning, TEXT("[SwanbladeAudio] No bundle found for state: %d"), (int32)NewState);
        return;
    }

    // Start playing new stems after a delay
    FTimerHandle TimerHandle;
    GetWorld()->GetTimerManager().SetTimer(TimerHandle, [this, Bundle]()
    {
        TArray<USoundWave*> Stems = Bundle->GetAllStems();
        TArray<ESwanbladeStemType> StemTypes = {
            ESwanbladeStemType::Drums,
            ESwanbladeStemType::Bass,
            ESwanbladeStemType::Melody,
            ESwanbladeStemType::Harmony,
            ESwanbladeStemType::Atmosphere,
            ESwanbladeStemType::FX,
            ESwanbladeStemType::Vocals
        };

        for (int32 i = 0; i < Stems.Num() && i < StemTypes.Num(); i++)
        {
            if (Stems[i] && StemComponents.Contains(StemTypes[i]))
            {
                UAudioComponent* Comp = StemComponents[StemTypes[i]];
                Comp->SetSound(Stems[i]);
                Comp->Play(0.f);
                TargetStemVolumes[StemTypes[i]] = 1.f;
            }
        }
    }, CrossfadeDuration * 0.5f, false);
}

USwanbladeAudioBundleBase* ASwanbladeAudioManager::GetBundleForState(ESwanbladeAudioState State)
{
    switch (State)
    {
${bundles.map((b) => `        case ESwanbladeAudioState::E${toPascalCase(b.gameState)}:
            return ${b.gameState}Bundle;`).join("\n")}
        default:
            return nullptr;
    }
}

float ASwanbladeAudioManager::GetCurrentBPM() const
{
    USwanbladeAudioBundleBase* Bundle = const_cast<ASwanbladeAudioManager*>(this)->GetBundleForState(CurrentState);
    return Bundle ? Bundle->GetBPM() : 120.f;
}

void ASwanbladeAudioManager::SetStemVolume(ESwanbladeStemType StemType, float Volume)
{
    Volume = FMath::Clamp(Volume, 0.f, 1.f);
    TargetStemVolumes[StemType] = Volume;
    CachedStemVolumes[StemType] = Volume;
}

float ASwanbladeAudioManager::GetStemVolume(ESwanbladeStemType StemType) const
{
    return TargetStemVolumes.FindRef(StemType);
}

void ASwanbladeAudioManager::MuteStem(ESwanbladeStemType StemType)
{
    TargetStemVolumes[StemType] = 0.f;
}

void ASwanbladeAudioManager::UnmuteStem(ESwanbladeStemType StemType)
{
    TargetStemVolumes[StemType] = CachedStemVolumes[StemType];
}

void ASwanbladeAudioManager::MapParameterToStem(FName ParameterName, ESwanbladeStemType StemType, float MinValue, float MaxValue)
{
    FParameterMapping Mapping;
    Mapping.StemType = StemType;
    Mapping.MinValue = MinValue;
    Mapping.MaxValue = MaxValue;
    ParameterMappings.Add(ParameterName, Mapping);
}

void ASwanbladeAudioManager::SetParameterValue(FName ParameterName, float Value)
{
    if (FParameterMapping* Mapping = ParameterMappings.Find(ParameterName))
    {
        // Normalize value to 0-1 range
        float NormalizedValue = FMath::GetMappedRangeValueClamped(
            FVector2D(Mapping->MinValue, Mapping->MaxValue),
            FVector2D(0.f, 1.f),
            Value
        );

        SetStemVolume(Mapping->StemType, NormalizedValue);
    }
}

void ASwanbladeAudioManager::UpdateBeatTracking(float DeltaTime)
{
    float BPM = GetCurrentBPM();
    float BeatDuration = 60.f / BPM;

    BeatAccumulator += DeltaTime;

    if (BeatAccumulator >= BeatDuration)
    {
        BeatAccumulator -= BeatDuration;
        CurrentBeat++;
        OnBeatHit.Broadcast(CurrentBeat);
    }
}
`;
}

// ==================== Blueprint Library ====================

/**
 * Generate Blueprint function library
 */
export function generateUnrealBlueprintLibrary(
  projectName: string = "SwanbladeAudio"
): string {
  return `// ${projectName} Blueprint Library
// Auto-generated by Swanblade

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "SwanbladeAudioManager.h"
#include "SwanbladeBlueprintLibrary.generated.h"

/**
 * Blueprint utility functions for Swanblade Audio
 */
UCLASS()
class ${projectName.toUpperCase()}_API USwanbladeBlueprintLibrary : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()

public:
    /**
     * Set game audio state (convenience function)
     */
    UFUNCTION(BlueprintCallable, Category = "Swanblade|Audio", meta = (WorldContext = "WorldContextObject"))
    static void SetGameAudioState(UObject* WorldContextObject, ESwanbladeAudioState NewState);

    /**
     * Get current game audio state
     */
    UFUNCTION(BlueprintPure, Category = "Swanblade|Audio", meta = (WorldContext = "WorldContextObject"))
    static ESwanbladeAudioState GetGameAudioState(UObject* WorldContextObject);

    /**
     * Set stem volume by type
     */
    UFUNCTION(BlueprintCallable, Category = "Swanblade|Audio|Stems", meta = (WorldContext = "WorldContextObject"))
    static void SetStemVolumeByType(UObject* WorldContextObject, ESwanbladeStemType StemType, float Volume);

    /**
     * Map health to drums volume (common pattern)
     */
    UFUNCTION(BlueprintCallable, Category = "Swanblade|Audio|Presets", meta = (WorldContext = "WorldContextObject"))
    static void MapHealthToDrums(UObject* WorldContextObject, float HealthPercent);

    /**
     * Map combat intensity to overall mix
     */
    UFUNCTION(BlueprintCallable, Category = "Swanblade|Audio|Presets", meta = (WorldContext = "WorldContextObject"))
    static void SetCombatIntensity(UObject* WorldContextObject, float Intensity);

    /**
     * Transition to stealth mode (mute percussion, boost atmosphere)
     */
    UFUNCTION(BlueprintCallable, Category = "Swanblade|Audio|Presets", meta = (WorldContext = "WorldContextObject"))
    static void EnterStealthMode(UObject* WorldContextObject);

    /**
     * Exit stealth mode (restore normal mix)
     */
    UFUNCTION(BlueprintCallable, Category = "Swanblade|Audio|Presets", meta = (WorldContext = "WorldContextObject"))
    static void ExitStealthMode(UObject* WorldContextObject);
};
`;
}

// ==================== Gameplay Tags ====================

/**
 * Generate gameplay tags configuration
 */
export function generateUnrealGameplayTags(bundles: StemBundle[]): string {
  const states = [...new Set(bundles.map((b) => b.gameState))];

  return `// Gameplay Tags for Swanblade Audio
// Add these to your project's DefaultGameplayTags.ini

[/Script/GameplayTags.GameplayTagsSettings]
+GameplayTagList=(Tag="Audio.State.${states.join('",Comment="")\n+GameplayTagList=(Tag="Audio.State.')}",Comment="")
+GameplayTagList=(Tag="Audio.Stem.Drums",Comment="")
+GameplayTagList=(Tag="Audio.Stem.Bass",Comment="")
+GameplayTagList=(Tag="Audio.Stem.Melody",Comment="")
+GameplayTagList=(Tag="Audio.Stem.Harmony",Comment="")
+GameplayTagList=(Tag="Audio.Stem.Atmosphere",Comment="")
+GameplayTagList=(Tag="Audio.Stem.FX",Comment="")
+GameplayTagList=(Tag="Audio.Stem.Vocals",Comment="")
+GameplayTagList=(Tag="Audio.Event.BeatHit",Comment="")
+GameplayTagList=(Tag="Audio.Event.StateChanged",Comment="")
`;
}

// ==================== README ====================

/**
 * Generate README for Unreal package
 */
export function generateUnrealReadme(
  bundles: StemBundle[],
  projectName: string = "SwanbladeAudio"
): string {
  return `# ${projectName} - Swanblade Audio Package for Unreal Engine

## Overview

This Unreal Engine plugin was generated by Swanblade and contains:
- ${bundles.length} audio bundle(s) for different game states
- ASwanbladeAudioManager actor for state-driven playback
- Blueprint-callable functions for easy integration
- RTPC parameter mapping for adaptive audio

## Quick Start

1. **Import the plugin** into your Unreal project
2. **Place SwanbladeAudioManager** actor in your level
3. **Call SetAudioState** to trigger audio transitions

### C++
\`\`\`cpp
// Get audio manager
ASwanbladeAudioManager* AudioManager = ASwanbladeAudioManager::GetInstance();

// Change to combat music
AudioManager->SetAudioState(ESwanbladeAudioState::ECombat);

// Map health to drums volume
AudioManager->MapParameterToStem(TEXT("Health"), ESwanbladeStemType::Drums, 0.f, 100.f);
AudioManager->SetParameterValue(TEXT("Health"), PlayerHealth);
\`\`\`

### Blueprint
- Use \`Set Game Audio State\` node
- Use \`Set Stem Volume By Type\` for individual control
- Use preset functions like \`Map Health To Drums\`

## Audio Bundles

${bundles.map((b) => `- **${b.name}** (${b.gameState}): ${b.stems.length} stems, ${b.manifest.bpm} BPM, ${b.manifest.duration}s`).join("\n")}

## RTPC Integration

The audio manager supports real-time parameter control:

\`\`\`cpp
// Map health (0-100) to drums volume
AudioManager->MapParameterToStem(TEXT("Health"), ESwanbladeStemType::Drums, 0.f, 100.f);

// Update during gameplay
AudioManager->SetParameterValue(TEXT("Health"), CurrentHealth);
\`\`\`

## Events

- \`OnAudioStateChanged\` - Fires when state changes
- \`OnBeatHit\` - Fires on each beat (synced to BPM)

---
Generated by Swanblade | https://swanblade.io
`;
}

// ==================== Full Package Generation ====================

/**
 * Generate complete Unreal package
 */
export function generateUnrealPackage(
  bundles: StemBundle[],
  projectName: string = "SwanbladeAudio"
): UnrealPackage {
  const manifest: UnrealManifest = {
    name: projectName,
    version: "1.0.0",
    unrealVersion: "5.3",
    generator: "swanblade",
    generatedAt: new Date().toISOString(),
    bundles: bundles.map((b) => ({
      id: b.id,
      name: b.name,
      gameState: b.gameState,
      stemCount: b.stems.length,
      bpm: b.manifest.bpm,
      duration: b.manifest.duration,
    })),
  };

  // Generate DataAssets for each bundle
  const dataAssets = new Map<string, string>();
  for (const bundle of bundles) {
    const className = `${toPascalCase(bundle.gameState)}AudioBundle`;
    dataAssets.set(
      `${className}.h`,
      generateBundleDataAsset(bundle, projectName)
    );
  }

  return {
    manifest,
    audioManagerHeader: generateUnrealAudioManagerHeader(bundles, projectName),
    audioManagerCpp: generateUnrealAudioManagerCpp(bundles, projectName),
    dataAssets,
    blueprintLibrary: generateUnrealBlueprintLibrary(projectName),
    gameplayTags: generateUnrealGameplayTags(bundles),
    readme: generateUnrealReadme(bundles, projectName),
  };
}

/**
 * Generate DataAsset header for a specific bundle
 */
function generateBundleDataAsset(
  bundle: StemBundle,
  projectName: string
): string {
  const className = `U${toPascalCase(bundle.gameState)}AudioBundle`;

  return `// Audio bundle for ${bundle.gameState} game state
// Generated by Swanblade on ${bundle.createdAt}

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "Sound/SoundWave.h"
#include "${toPascalCase(bundle.gameState)}AudioBundle.generated.h"

/**
 * Base class for Swanblade audio bundles
 */
UCLASS(Abstract)
class USwanbladeAudioBundleBase : public UDataAsset
{
    GENERATED_BODY()

public:
    virtual TArray<USoundWave*> GetAllStems() const { return TArray<USoundWave*>(); }
    virtual float GetBPM() const { return 120.f; }
};

/**
 * ${bundle.gameState} audio bundle
 */
UCLASS(BlueprintType)
class ${projectName.toUpperCase()}_API ${className} : public USwanbladeAudioBundleBase
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Bundle Info")
    FString BundleId = TEXT("${bundle.id}");

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Bundle Info")
    FString GameState = TEXT("${bundle.gameState}");

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Bundle Info")
    float BPM = ${bundle.manifest.bpm}f;

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Bundle Info")
    FString MusicalKey = TEXT("${bundle.manifest.key}");

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Bundle Info")
    float Duration = ${bundle.manifest.duration}f;

    // Stems
${bundle.stems.map((stem) => `    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Stems")
    USoundWave* ${toPascalCase(stem.stemType)}Stem;`).join("\n\n")}

    virtual TArray<USoundWave*> GetAllStems() const override
    {
        return { ${bundle.stems.map((s) => `${toPascalCase(s.stemType)}Stem`).join(", ")} };
    }

    virtual float GetBPM() const override { return BPM; }
};
`;
}

// ==================== Helpers ====================

function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]+/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join("");
}
