generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum VettingStatus {
  PENDING
  ACCEPTED
  WAITLISTED
  REVISION_REQUESTED
}

enum MembershipTier {
  FREE
  STANDARD
}

enum RelationshipStyle {
  MONOGAMOUS
  EXPLORING
  NON_MONOGAMOUS
  UNSURE
}

enum ConnectionPace {
  SLOW
  BALANCED
  FAST
  UNSURE
}

enum BoundaryType {
  EMOTIONAL
  PHYSICAL
  COMMUNICATION
  SPIRITUAL
  KINK
}

enum ApplicationStatus {
  PENDING
  ACCEPTED
  WAITLISTED
  REVISION_REQUESTED
}

enum MatchCandidateStatus {
  UNOPENED
  OPENED
  PASSED
  SAVED
}

enum MessageType {
  TEXT
  VOICE
  JOURNAL
}

enum UserRole {
  MEMBER
  ADMIN
}

model User {
  id                     String               @id @default(cuid())
  email                  String               @unique
  hashedPassword         String?
  name                   String?
  pronouns               String?
  genderIdentity         String
  sexuality              String
  avatarUrl              String?
  isVerified             Boolean              @default(false)
  vettingStatus          VettingStatus        @default(PENDING)
  isMember               Boolean              @default(false)
  membershipTier         MembershipTier       @default(FREE)
  spiritualityImportance Int
  spiritualityText       String?
  relationshipStyle      RelationshipStyle
  connectionPace         ConnectionPace
  role                   UserRole             @default(MEMBER)
  createdAt              DateTime             @default(now())
  updatedAt              DateTime             @updatedAt

  boundaries        Boundary[]
  application       Application?
  profileStory      ProfileStory?
  matchViewer       MatchCandidateDaily[]    @relation("Viewer")
  matchCandidate    MatchCandidateDaily[]    @relation("Candidate")
  connectionsA      Connection[]             @relation("ConnectionsA")
  connectionsB      Connection[]             @relation("ConnectionsB")
  messages          Message[]
  sessions          Session[]
  accounts          Account[]
  verificationCodes VerificationToken[]
}

model Boundary {
  id              String        @id @default(cuid())
  userId          String
  type            BoundaryType
  label           String
  importanceLevel Int

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Application {
  id            String            @id @default(cuid())
  userId        String            @unique
  q1            String
  q2            String
  q3            String
  reviewerNotes String?
  status        ApplicationStatus @default(PENDING)
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ProfileStory {
  id                   String   @id @default(cuid())
  userId               String   @unique
  soulStatement        String
  healingFrom          String
  growingInto          String
  intimacyLanguages    String[]
  sacrednessMeaning    String?
  vulnerabilityAudioUrl String?
  calmVoiceAudioUrl    String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model MatchCandidateDaily {
  id          String               @id @default(cuid())
  viewerId    String
  candidateId String
  date        DateTime
  status      MatchCandidateStatus @default(UNOPENED)
  createdAt   DateTime             @default(now())

  viewer    User @relation("Viewer", fields: [viewerId], references: [id], onDelete: Cascade)
  candidate User @relation("Candidate", fields: [candidateId], references: [id], onDelete: Cascade)

  @@unique([viewerId, candidateId, date])
  @@index([viewerId, date])
}

model Connection {
  id                String    @id @default(cuid())
  userAId           String
  userBId           String
  isActive          Boolean   @default(true)
  createdAt         DateTime  @default(now())
  lastInteractionAt DateTime  @default(now())
  openingIntent     String?
  sharedIntention   String?

  userA   User     @relation("ConnectionsA", fields: [userAId], references: [id], onDelete: Cascade)
  userB   User     @relation("ConnectionsB", fields: [userBId], references: [id], onDelete: Cascade)
  messages Message[]

  @@unique([userAId, userBId])
}

model Message {
  id            String      @id @default(cuid())
  connectionId  String
  senderId      String
  type          MessageType
  text          String?
  audioUrl      String?
  createdAt     DateTime    @default(now())

  connection Connection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  sender     User       @relation(fields: [senderId], references: [id])
}

model MatchPreference {
  id             String  @id @default(cuid())
  userId         String  @unique
  preferredPace  ConnectionPace?
  minSpirituality Int?
  maxSpirituality Int?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
